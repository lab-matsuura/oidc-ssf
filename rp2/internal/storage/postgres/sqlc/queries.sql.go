// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countSessionsByUser = `-- name: CountSessionsByUser :one
SELECT COUNT(*) FROM sessions WHERE user_sub = $1
`

func (q *Queries) CountSessionsByUser(ctx context.Context, userSub string) (int64, error) {
	row := q.db.QueryRow(ctx, countSessionsByUser, userSub)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createOrUpdateUser = `-- name: CreateOrUpdateUser :one
INSERT INTO users (sub, email, name, role)
VALUES ($1, $2, $3, $4)
ON CONFLICT (sub) DO UPDATE SET
    email = EXCLUDED.email,
    name = EXCLUDED.name,
    updated_at = NOW()
RETURNING sub, email, name, role, created_at, updated_at
`

type CreateOrUpdateUserParams struct {
	Sub   string  `json:"sub"`
	Email *string `json:"email"`
	Name  *string `json:"name"`
	Role  string  `json:"role"`
}

func (q *Queries) CreateOrUpdateUser(ctx context.Context, arg CreateOrUpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createOrUpdateUser,
		arg.Sub,
		arg.Email,
		arg.Name,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.Sub,
		&i.Email,
		&i.Name,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSession = `-- name: CreateSession :one

INSERT INTO sessions (id, user_sub, access_token, id_token, refresh_token, expires_at)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_sub, access_token, id_token, refresh_token, expires_at, created_at
`

type CreateSessionParams struct {
	ID           string             `json:"id"`
	UserSub      string             `json:"user_sub"`
	AccessToken  string             `json:"access_token"`
	IDToken      string             `json:"id_token"`
	RefreshToken *string            `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
}

// ===================
// Sessions
// ===================
func (q *Queries) CreateSession(ctx context.Context, arg CreateSessionParams) (Session, error) {
	row := q.db.QueryRow(ctx, createSession,
		arg.ID,
		arg.UserSub,
		arg.AccessToken,
		arg.IDToken,
		arg.RefreshToken,
		arg.ExpiresAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserSub,
		&i.AccessToken,
		&i.IDToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteExpiredSessions = `-- name: DeleteExpiredSessions :execrows
DELETE FROM sessions WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredSessions(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredSessions)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteSSFConfig = `-- name: DeleteSSFConfig :exec
DELETE FROM ssf_config WHERE id = 1
`

func (q *Queries) DeleteSSFConfig(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteSSFConfig)
	return err
}

const deleteSession = `-- name: DeleteSession :exec
DELETE FROM sessions WHERE id = $1
`

func (q *Queries) DeleteSession(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteSession, id)
	return err
}

const deleteSessionsByUserSub = `-- name: DeleteSessionsByUserSub :execrows
DELETE FROM sessions WHERE user_sub = $1
`

func (q *Queries) DeleteSessionsByUserSub(ctx context.Context, userSub string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteSessionsByUserSub, userSub)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users WHERE sub = $1
`

func (q *Queries) DeleteUser(ctx context.Context, sub string) error {
	_, err := q.db.Exec(ctx, deleteUser, sub)
	return err
}

const getSSFConfig = `-- name: GetSSFConfig :one

SELECT id, stream_id, created_at, updated_at FROM ssf_config WHERE id = 1 LIMIT 1
`

// ===================
// SSF Config
// ===================
func (q *Queries) GetSSFConfig(ctx context.Context) (SsfConfig, error) {
	row := q.db.QueryRow(ctx, getSSFConfig)
	var i SsfConfig
	err := row.Scan(
		&i.ID,
		&i.StreamID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSession = `-- name: GetSession :one
SELECT id, user_sub, access_token, id_token, refresh_token, expires_at, created_at FROM sessions
WHERE id = $1 AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetSession(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, getSession, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.UserSub,
		&i.AccessToken,
		&i.IDToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSessionWithUser = `-- name: GetSessionWithUser :one
SELECT
    s.id,
    s.user_sub,
    s.access_token,
    s.id_token,
    s.refresh_token,
    s.expires_at,
    s.created_at,
    u.email as user_email,
    u.name as user_name,
    u.role as user_role
FROM sessions s
JOIN users u ON s.user_sub = u.sub
WHERE s.id = $1 AND s.expires_at > NOW()
LIMIT 1
`

type GetSessionWithUserRow struct {
	ID           string             `json:"id"`
	UserSub      string             `json:"user_sub"`
	AccessToken  string             `json:"access_token"`
	IDToken      string             `json:"id_token"`
	RefreshToken *string            `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UserEmail    *string            `json:"user_email"`
	UserName     *string            `json:"user_name"`
	UserRole     string             `json:"user_role"`
}

func (q *Queries) GetSessionWithUser(ctx context.Context, id string) (GetSessionWithUserRow, error) {
	row := q.db.QueryRow(ctx, getSessionWithUser, id)
	var i GetSessionWithUserRow
	err := row.Scan(
		&i.ID,
		&i.UserSub,
		&i.AccessToken,
		&i.IDToken,
		&i.RefreshToken,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.UserEmail,
		&i.UserName,
		&i.UserRole,
	)
	return i, err
}

const getUser = `-- name: GetUser :one

SELECT sub, email, name, role, created_at, updated_at FROM users WHERE sub = $1 LIMIT 1
`

// ===================
// Users
// ===================
func (q *Queries) GetUser(ctx context.Context, sub string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, sub)
	var i User
	err := row.Scan(
		&i.Sub,
		&i.Email,
		&i.Name,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllSessions = `-- name: ListAllSessions :many
SELECT
    s.id,
    s.user_sub,
    s.access_token,
    s.id_token,
    s.refresh_token,
    s.expires_at,
    s.created_at,
    u.email as user_email,
    u.name as user_name,
    u.role as user_role
FROM sessions s
JOIN users u ON s.user_sub = u.sub
WHERE s.expires_at > NOW()
ORDER BY s.created_at DESC
`

type ListAllSessionsRow struct {
	ID           string             `json:"id"`
	UserSub      string             `json:"user_sub"`
	AccessToken  string             `json:"access_token"`
	IDToken      string             `json:"id_token"`
	RefreshToken *string            `json:"refresh_token"`
	ExpiresAt    pgtype.Timestamptz `json:"expires_at"`
	CreatedAt    pgtype.Timestamptz `json:"created_at"`
	UserEmail    *string            `json:"user_email"`
	UserName     *string            `json:"user_name"`
	UserRole     string             `json:"user_role"`
}

func (q *Queries) ListAllSessions(ctx context.Context) ([]ListAllSessionsRow, error) {
	rows, err := q.db.Query(ctx, listAllSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListAllSessionsRow{}
	for rows.Next() {
		var i ListAllSessionsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserSub,
			&i.AccessToken,
			&i.IDToken,
			&i.RefreshToken,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.UserEmail,
			&i.UserName,
			&i.UserRole,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSessionsByUser = `-- name: ListSessionsByUser :many
SELECT id, user_sub, access_token, id_token, refresh_token, expires_at, created_at FROM sessions WHERE user_sub = $1 ORDER BY created_at DESC
`

func (q *Queries) ListSessionsByUser(ctx context.Context, userSub string) ([]Session, error) {
	rows, err := q.db.Query(ctx, listSessionsByUser, userSub)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Session{}
	for rows.Next() {
		var i Session
		if err := rows.Scan(
			&i.ID,
			&i.UserSub,
			&i.AccessToken,
			&i.IDToken,
			&i.RefreshToken,
			&i.ExpiresAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT sub, email, name, role, created_at, updated_at FROM users ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.Sub,
			&i.Email,
			&i.Name,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE users SET role = $2, updated_at = NOW() WHERE sub = $1
`

type UpdateUserRoleParams struct {
	Sub  string `json:"sub"`
	Role string `json:"role"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.Sub, arg.Role)
	return err
}

const upsertSSFConfig = `-- name: UpsertSSFConfig :one
INSERT INTO ssf_config (id, stream_id)
VALUES (1, $1)
ON CONFLICT (id) DO UPDATE SET
    stream_id = EXCLUDED.stream_id,
    updated_at = NOW()
RETURNING id, stream_id, created_at, updated_at
`

func (q *Queries) UpsertSSFConfig(ctx context.Context, streamID *string) (SsfConfig, error) {
	row := q.db.QueryRow(ctx, upsertSSFConfig, streamID)
	var i SsfConfig
	err := row.Scan(
		&i.ID,
		&i.StreamID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
