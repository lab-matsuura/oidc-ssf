// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const ackSSFDeliveries = `-- name: AckSSFDeliveries :exec
UPDATE ssf_event_deliveries
SET status = 'acked', acked_at = NOW()
WHERE stream_id = $1 AND jti = ANY($2::text[])
`

type AckSSFDeliveriesParams struct {
	StreamID pgtype.UUID `json:"stream_id"`
	Column2  []string    `json:"column_2"`
}

func (q *Queries) AckSSFDeliveries(ctx context.Context, arg AckSSFDeliveriesParams) error {
	_, err := q.db.Exec(ctx, ackSSFDeliveries, arg.StreamID, arg.Column2)
	return err
}

const ackSSFDelivery = `-- name: AckSSFDelivery :exec
UPDATE ssf_event_deliveries
SET status = 'acked', acked_at = NOW()
WHERE stream_id = $1 AND jti = $2
`

type AckSSFDeliveryParams struct {
	StreamID pgtype.UUID `json:"stream_id"`
	Jti      string      `json:"jti"`
}

func (q *Queries) AckSSFDelivery(ctx context.Context, arg AckSSFDeliveryParams) error {
	_, err := q.db.Exec(ctx, ackSSFDelivery, arg.StreamID, arg.Jti)
	return err
}

const blacklistJTI = `-- name: BlacklistJTI :exec
INSERT INTO blacklisted_jtis (jti, expires_at)
VALUES ($1, $2)
ON CONFLICT (jti) DO NOTHING
`

type BlacklistJTIParams struct {
	Jti       string             `json:"jti"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

func (q *Queries) BlacklistJTI(ctx context.Context, arg BlacklistJTIParams) error {
	_, err := q.db.Exec(ctx, blacklistJTI, arg.Jti, arg.ExpiresAt)
	return err
}

const checkEmailExists = `-- name: CheckEmailExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE email = $1) AS exists
`

func (q *Queries) CheckEmailExists(ctx context.Context, email string) (bool, error) {
	row := q.db.QueryRow(ctx, checkEmailExists, email)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUsernameExists = `-- name: CheckUsernameExists :one
SELECT EXISTS(SELECT 1 FROM users WHERE username = $1) AS exists
`

func (q *Queries) CheckUsernameExists(ctx context.Context, username string) (bool, error) {
	row := q.db.QueryRow(ctx, checkUsernameExists, username)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const cleanupExpiredJTIs = `-- name: CleanupExpiredJTIs :exec
DELETE FROM blacklisted_jtis WHERE expires_at < NOW()
`

func (q *Queries) CleanupExpiredJTIs(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredJTIs)
	return err
}

const cleanupExpiredSessions = `-- name: CleanupExpiredSessions :exec
DELETE FROM idp_sessions
WHERE expires_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) CleanupExpiredSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupExpiredSessions)
	return err
}

const cleanupOldSSFDeliveries = `-- name: CleanupOldSSFDeliveries :exec
DELETE FROM ssf_event_deliveries WHERE created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) CleanupOldSSFDeliveries(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldSSFDeliveries)
	return err
}

const cleanupOldSSFEvents = `-- name: CleanupOldSSFEvents :exec
DELETE FROM ssf_events WHERE created_at < NOW() - INTERVAL '30 days'
`

func (q *Queries) CleanupOldSSFEvents(ctx context.Context) error {
	_, err := q.db.Exec(ctx, cleanupOldSSFEvents)
	return err
}

const countClients = `-- name: CountClients :one
SELECT COUNT(*) FROM clients
`

func (q *Queries) CountClients(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countClients)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSSFEventDeliveries = `-- name: CountSSFEventDeliveries :one
SELECT COUNT(*) FROM ssf_event_deliveries
`

func (q *Queries) CountSSFEventDeliveries(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSSFEventDeliveries)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSSFEventDeliveriesByStatus = `-- name: CountSSFEventDeliveriesByStatus :one
SELECT COUNT(*) FROM ssf_event_deliveries WHERE status = $1
`

func (q *Queries) CountSSFEventDeliveriesByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countSSFEventDeliveriesByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSSFEventDeliveriesByStream = `-- name: CountSSFEventDeliveriesByStream :one
SELECT COUNT(*) FROM ssf_event_deliveries WHERE stream_id = $1
`

func (q *Queries) CountSSFEventDeliveriesByStream(ctx context.Context, streamID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countSSFEventDeliveriesByStream, streamID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSSFEventDeliveriesFiltered = `-- name: CountSSFEventDeliveriesFiltered :one
SELECT COUNT(*) FROM ssf_event_deliveries d
JOIN ssf_events e ON d.event_id = e.id
WHERE ($1::uuid IS NULL OR d.stream_id = $1)
  AND ($2::text IS NULL OR d.status = $2)
  AND ($3::text IS NULL OR e.event_type = $3)
`

type CountSSFEventDeliveriesFilteredParams struct {
	StreamID  pgtype.UUID `json:"stream_id"`
	Status    *string     `json:"status"`
	EventType *string     `json:"event_type"`
}

func (q *Queries) CountSSFEventDeliveriesFiltered(ctx context.Context, arg CountSSFEventDeliveriesFilteredParams) (int64, error) {
	row := q.db.QueryRow(ctx, countSSFEventDeliveriesFiltered, arg.StreamID, arg.Status, arg.EventType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSSFEvents = `-- name: CountSSFEvents :one
SELECT COUNT(*) FROM ssf_events
`

func (q *Queries) CountSSFEvents(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSSFEvents)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSSFStreams = `-- name: CountSSFStreams :one
SELECT COUNT(*) FROM ssf_streams
`

func (q *Queries) CountSSFStreams(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countSSFStreams)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countSSFStreamsByStatus = `-- name: CountSSFStreamsByStatus :one
SELECT COUNT(*) FROM ssf_streams WHERE status = $1
`

func (q *Queries) CountSSFStreamsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRow(ctx, countSSFStreamsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUserSessions = `-- name: CountUserSessions :one
SELECT COUNT(*) FROM idp_sessions
WHERE user_id = $1
`

func (q *Queries) CountUserSessions(ctx context.Context, userID pgtype.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUserSessions, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users WHERE account_status != 'deleted'
`

func (q *Queries) CountUsers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createAccessToken = `-- name: CreateAccessToken :exec
INSERT INTO access_tokens (signature, request_data, request_id, expires_at)
VALUES ($1, $2, $3, $4)
`

type CreateAccessTokenParams struct {
	Signature   string             `json:"signature"`
	RequestData []byte             `json:"request_data"`
	RequestID   string             `json:"request_id"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

// Access Tokens
func (q *Queries) CreateAccessToken(ctx context.Context, arg CreateAccessTokenParams) error {
	_, err := q.db.Exec(ctx, createAccessToken,
		arg.Signature,
		arg.RequestData,
		arg.RequestID,
		arg.ExpiresAt,
	)
	return err
}

const createAuthorizeCode = `-- name: CreateAuthorizeCode :exec
INSERT INTO authorize_codes (code, active, request_data, expires_at)
VALUES ($1, $2, $3, $4)
`

type CreateAuthorizeCodeParams struct {
	Code        string             `json:"code"`
	Active      bool               `json:"active"`
	RequestData []byte             `json:"request_data"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

// Authorization Codes
func (q *Queries) CreateAuthorizeCode(ctx context.Context, arg CreateAuthorizeCodeParams) error {
	_, err := q.db.Exec(ctx, createAuthorizeCode,
		arg.Code,
		arg.Active,
		arg.RequestData,
		arg.ExpiresAt,
	)
	return err
}

const createClient = `-- name: CreateClient :exec
INSERT INTO clients (
    id, secret, redirect_uris, grant_types, response_types, scopes, public
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
`

type CreateClientParams struct {
	ID            string `json:"id"`
	Secret        []byte `json:"secret"`
	RedirectUris  []byte `json:"redirect_uris"`
	GrantTypes    []byte `json:"grant_types"`
	ResponseTypes []byte `json:"response_types"`
	Scopes        []byte `json:"scopes"`
	Public        bool   `json:"public"`
}

func (q *Queries) CreateClient(ctx context.Context, arg CreateClientParams) error {
	_, err := q.db.Exec(ctx, createClient,
		arg.ID,
		arg.Secret,
		arg.RedirectUris,
		arg.GrantTypes,
		arg.ResponseTypes,
		arg.Scopes,
		arg.Public,
	)
	return err
}

const createIDPSession = `-- name: CreateIDPSession :one

INSERT INTO idp_sessions (user_id, user_agent, ip_address, expires_at)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, user_agent, ip_address, created_at, expires_at, revoked_at
`

type CreateIDPSessionParams struct {
	UserID    pgtype.UUID        `json:"user_id"`
	UserAgent *string            `json:"user_agent"`
	IpAddress *string            `json:"ip_address"`
	ExpiresAt pgtype.Timestamptz `json:"expires_at"`
}

// ===================
// IdP Sessions (for SLO)
// ===================
func (q *Queries) CreateIDPSession(ctx context.Context, arg CreateIDPSessionParams) (IdpSession, error) {
	row := q.db.QueryRow(ctx, createIDPSession,
		arg.UserID,
		arg.UserAgent,
		arg.IpAddress,
		arg.ExpiresAt,
	)
	var i IdpSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserAgent,
		&i.IpAddress,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
	)
	return i, err
}

const createOIDCSession = `-- name: CreateOIDCSession :exec
INSERT INTO oidc_sessions (authorize_code, request_data)
VALUES ($1, $2)
`

type CreateOIDCSessionParams struct {
	AuthorizeCode string `json:"authorize_code"`
	RequestData   []byte `json:"request_data"`
}

// OIDC Sessions
func (q *Queries) CreateOIDCSession(ctx context.Context, arg CreateOIDCSessionParams) error {
	_, err := q.db.Exec(ctx, createOIDCSession, arg.AuthorizeCode, arg.RequestData)
	return err
}

const createOwnerUser = `-- name: CreateOwnerUser :one
INSERT INTO users (username, email, password_hash, display_name, role)
VALUES ($1, $2, $3, $4, 'owner')
RETURNING id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status
`

type CreateOwnerUserParams struct {
	Username     string  `json:"username"`
	Email        string  `json:"email"`
	PasswordHash []byte  `json:"password_hash"`
	DisplayName  *string `json:"display_name"`
}

func (q *Queries) CreateOwnerUser(ctx context.Context, arg CreateOwnerUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createOwnerUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.AccountStatus,
	)
	return i, err
}

const createPARSession = `-- name: CreatePARSession :exec
INSERT INTO par_sessions (request_uri, request_data, expires_at)
VALUES ($1, $2, $3)
`

type CreatePARSessionParams struct {
	RequestUri  string             `json:"request_uri"`
	RequestData []byte             `json:"request_data"`
	ExpiresAt   pgtype.Timestamptz `json:"expires_at"`
}

// PAR Sessions
func (q *Queries) CreatePARSession(ctx context.Context, arg CreatePARSessionParams) error {
	_, err := q.db.Exec(ctx, createPARSession, arg.RequestUri, arg.RequestData, arg.ExpiresAt)
	return err
}

const createPKCESession = `-- name: CreatePKCESession :exec
INSERT INTO pkce_sessions (code, request_data)
VALUES ($1, $2)
`

type CreatePKCESessionParams struct {
	Code        string `json:"code"`
	RequestData []byte `json:"request_data"`
}

// PKCE Sessions
func (q *Queries) CreatePKCESession(ctx context.Context, arg CreatePKCESessionParams) error {
	_, err := q.db.Exec(ctx, createPKCESession, arg.Code, arg.RequestData)
	return err
}

const createRefreshToken = `-- name: CreateRefreshToken :exec
INSERT INTO refresh_tokens (
    signature, active, request_data, request_id, access_token_signature, expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6
)
`

type CreateRefreshTokenParams struct {
	Signature            string             `json:"signature"`
	Active               bool               `json:"active"`
	RequestData          []byte             `json:"request_data"`
	RequestID            string             `json:"request_id"`
	AccessTokenSignature *string            `json:"access_token_signature"`
	ExpiresAt            pgtype.Timestamptz `json:"expires_at"`
}

// Refresh Tokens
func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) error {
	_, err := q.db.Exec(ctx, createRefreshToken,
		arg.Signature,
		arg.Active,
		arg.RequestData,
		arg.RequestID,
		arg.AccessTokenSignature,
		arg.ExpiresAt,
	)
	return err
}

const createSSFEvent = `-- name: CreateSSFEvent :one

INSERT INTO ssf_events (event_type, subject_identifier, payload)
VALUES ($1, $2, $3)
RETURNING id, event_type, subject_identifier, payload, created_at
`

type CreateSSFEventParams struct {
	EventType         string  `json:"event_type"`
	SubjectIdentifier *string `json:"subject_identifier"`
	Payload           []byte  `json:"payload"`
}

// ===================
// SSF: Events (normalized)
// ===================
func (q *Queries) CreateSSFEvent(ctx context.Context, arg CreateSSFEventParams) (SsfEvent, error) {
	row := q.db.QueryRow(ctx, createSSFEvent, arg.EventType, arg.SubjectIdentifier, arg.Payload)
	var i SsfEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.SubjectIdentifier,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const createSSFEventDelivery = `-- name: CreateSSFEventDelivery :one

INSERT INTO ssf_event_deliveries (event_id, stream_id, jti, set_token, status, next_retry_at)
VALUES ($1, $2, $3, $4, $5, NOW())
RETURNING id, event_id, stream_id, jti, set_token, status, attempts, max_attempts, last_error, next_retry_at, created_at, sent_at, acked_at
`

type CreateSSFEventDeliveryParams struct {
	EventID  pgtype.UUID `json:"event_id"`
	StreamID pgtype.UUID `json:"stream_id"`
	Jti      string      `json:"jti"`
	SetToken string      `json:"set_token"`
	Status   string      `json:"status"`
}

// ===================
// SSF: Event Deliveries (normalized)
// ===================
func (q *Queries) CreateSSFEventDelivery(ctx context.Context, arg CreateSSFEventDeliveryParams) (SsfEventDelivery, error) {
	row := q.db.QueryRow(ctx, createSSFEventDelivery,
		arg.EventID,
		arg.StreamID,
		arg.Jti,
		arg.SetToken,
		arg.Status,
	)
	var i SsfEventDelivery
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.StreamID,
		&i.Jti,
		&i.SetToken,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.SentAt,
		&i.AckedAt,
	)
	return i, err
}

const createSSFStream = `-- name: CreateSSFStream :one

INSERT INTO ssf_streams (
    client_id, audience, delivery_method, endpoint_url, authorization_header,
    events_requested, events_delivered, description
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, client_id, audience, delivery_method, endpoint_url, authorization_header, events_requested, events_delivered, status, status_reason, description, created_at, updated_at
`

type CreateSSFStreamParams struct {
	ClientID            *string  `json:"client_id"`
	Audience            []string `json:"audience"`
	DeliveryMethod      string   `json:"delivery_method"`
	EndpointUrl         string   `json:"endpoint_url"`
	AuthorizationHeader *string  `json:"authorization_header"`
	EventsRequested     []string `json:"events_requested"`
	EventsDelivered     []string `json:"events_delivered"`
	Description         *string  `json:"description"`
}

// ===================
// SSF: Streams
// ===================
func (q *Queries) CreateSSFStream(ctx context.Context, arg CreateSSFStreamParams) (SsfStream, error) {
	row := q.db.QueryRow(ctx, createSSFStream,
		arg.ClientID,
		arg.Audience,
		arg.DeliveryMethod,
		arg.EndpointUrl,
		arg.AuthorizationHeader,
		arg.EventsRequested,
		arg.EventsDelivered,
		arg.Description,
	)
	var i SsfStream
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Audience,
		&i.DeliveryMethod,
		&i.EndpointUrl,
		&i.AuthorizationHeader,
		&i.EventsRequested,
		&i.EventsDelivered,
		&i.Status,
		&i.StatusReason,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createSSFStreamSubject = `-- name: CreateSSFStreamSubject :one

INSERT INTO ssf_stream_subjects (stream_id, subject_format, subject_identifier, verified)
VALUES ($1, $2, $3, $4)
ON CONFLICT (stream_id, subject_format, subject_identifier) DO UPDATE
SET verified = EXCLUDED.verified
RETURNING id, stream_id, subject_format, subject_identifier, verified, created_at
`

type CreateSSFStreamSubjectParams struct {
	StreamID          pgtype.UUID `json:"stream_id"`
	SubjectFormat     string      `json:"subject_format"`
	SubjectIdentifier string      `json:"subject_identifier"`
	Verified          bool        `json:"verified"`
}

// ===================
// SSF: Stream Subjects
// ===================
func (q *Queries) CreateSSFStreamSubject(ctx context.Context, arg CreateSSFStreamSubjectParams) (SsfStreamSubject, error) {
	row := q.db.QueryRow(ctx, createSSFStreamSubject,
		arg.StreamID,
		arg.SubjectFormat,
		arg.SubjectIdentifier,
		arg.Verified,
	)
	var i SsfStreamSubject
	err := row.Scan(
		&i.ID,
		&i.StreamID,
		&i.SubjectFormat,
		&i.SubjectIdentifier,
		&i.Verified,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, password_hash, display_name)
VALUES ($1, $2, $3, $4)
RETURNING id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status
`

type CreateUserParams struct {
	Username     string  `json:"username"`
	Email        string  `json:"email"`
	PasswordHash []byte  `json:"password_hash"`
	DisplayName  *string `json:"display_name"`
}

// Users
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.AccountStatus,
	)
	return i, err
}

const createUserByAdmin = `-- name: CreateUserByAdmin :one
INSERT INTO users (username, email, password_hash, display_name, role)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status
`

type CreateUserByAdminParams struct {
	Username     string  `json:"username"`
	Email        string  `json:"email"`
	PasswordHash []byte  `json:"password_hash"`
	DisplayName  *string `json:"display_name"`
	Role         string  `json:"role"`
}

// Admin creates a user with optional role
func (q *Queries) CreateUserByAdmin(ctx context.Context, arg CreateUserByAdminParams) (User, error) {
	row := q.db.QueryRow(ctx, createUserByAdmin,
		arg.Username,
		arg.Email,
		arg.PasswordHash,
		arg.DisplayName,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.AccountStatus,
	)
	return i, err
}

const deleteAccessToken = `-- name: DeleteAccessToken :exec
DELETE FROM access_tokens WHERE signature = $1
`

func (q *Queries) DeleteAccessToken(ctx context.Context, signature string) error {
	_, err := q.db.Exec(ctx, deleteAccessToken, signature)
	return err
}

const deleteAccessTokenByRequestID = `-- name: DeleteAccessTokenByRequestID :exec
DELETE FROM access_tokens WHERE request_id = $1
`

func (q *Queries) DeleteAccessTokenByRequestID(ctx context.Context, requestID string) error {
	_, err := q.db.Exec(ctx, deleteAccessTokenByRequestID, requestID)
	return err
}

const deleteAllSSFStreamSubjects = `-- name: DeleteAllSSFStreamSubjects :exec
DELETE FROM ssf_stream_subjects WHERE stream_id = $1
`

func (q *Queries) DeleteAllSSFStreamSubjects(ctx context.Context, streamID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAllSSFStreamSubjects, streamID)
	return err
}

const deleteClient = `-- name: DeleteClient :exec
DELETE FROM clients WHERE id = $1
`

func (q *Queries) DeleteClient(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteClient, id)
	return err
}

const deleteExpiredAccessTokens = `-- name: DeleteExpiredAccessTokens :exec
DELETE FROM access_tokens WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredAccessTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAccessTokens)
	return err
}

const deleteExpiredAuthorizeCodes = `-- name: DeleteExpiredAuthorizeCodes :exec
DELETE FROM authorize_codes WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredAuthorizeCodes(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredAuthorizeCodes)
	return err
}

const deleteExpiredPARSessions = `-- name: DeleteExpiredPARSessions :exec
DELETE FROM par_sessions WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredPARSessions(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredPARSessions)
	return err
}

const deleteExpiredRefreshTokens = `-- name: DeleteExpiredRefreshTokens :exec
DELETE FROM refresh_tokens WHERE expires_at < NOW()
`

func (q *Queries) DeleteExpiredRefreshTokens(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteExpiredRefreshTokens)
	return err
}

const deleteOIDCSession = `-- name: DeleteOIDCSession :exec
DELETE FROM oidc_sessions WHERE authorize_code = $1
`

func (q *Queries) DeleteOIDCSession(ctx context.Context, authorizeCode string) error {
	_, err := q.db.Exec(ctx, deleteOIDCSession, authorizeCode)
	return err
}

const deletePARSession = `-- name: DeletePARSession :exec
DELETE FROM par_sessions WHERE request_uri = $1
`

func (q *Queries) DeletePARSession(ctx context.Context, requestUri string) error {
	_, err := q.db.Exec(ctx, deletePARSession, requestUri)
	return err
}

const deletePKCESession = `-- name: DeletePKCESession :exec
DELETE FROM pkce_sessions WHERE code = $1
`

func (q *Queries) DeletePKCESession(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, deletePKCESession, code)
	return err
}

const deleteRefreshToken = `-- name: DeleteRefreshToken :exec
DELETE FROM refresh_tokens WHERE signature = $1
`

func (q *Queries) DeleteRefreshToken(ctx context.Context, signature string) error {
	_, err := q.db.Exec(ctx, deleteRefreshToken, signature)
	return err
}

const deleteSSFStream = `-- name: DeleteSSFStream :exec
DELETE FROM ssf_streams WHERE id = $1
`

func (q *Queries) DeleteSSFStream(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteSSFStream, id)
	return err
}

const deleteSSFStreamSubject = `-- name: DeleteSSFStreamSubject :exec
DELETE FROM ssf_stream_subjects
WHERE stream_id = $1 AND subject_format = $2 AND subject_identifier = $3
`

type DeleteSSFStreamSubjectParams struct {
	StreamID          pgtype.UUID `json:"stream_id"`
	SubjectFormat     string      `json:"subject_format"`
	SubjectIdentifier string      `json:"subject_identifier"`
}

func (q *Queries) DeleteSSFStreamSubject(ctx context.Context, arg DeleteSSFStreamSubjectParams) error {
	_, err := q.db.Exec(ctx, deleteSSFStreamSubject, arg.StreamID, arg.SubjectFormat, arg.SubjectIdentifier)
	return err
}

const getAccessToken = `-- name: GetAccessToken :one
SELECT signature, request_data, request_id, expires_at, created_at FROM access_tokens WHERE signature = $1 LIMIT 1
`

func (q *Queries) GetAccessToken(ctx context.Context, signature string) (AccessToken, error) {
	row := q.db.QueryRow(ctx, getAccessToken, signature)
	var i AccessToken
	err := row.Scan(
		&i.Signature,
		&i.RequestData,
		&i.RequestID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getAccessTokenByRequestID = `-- name: GetAccessTokenByRequestID :one
SELECT signature, request_data, request_id, expires_at, created_at FROM access_tokens WHERE request_id = $1 LIMIT 1
`

func (q *Queries) GetAccessTokenByRequestID(ctx context.Context, requestID string) (AccessToken, error) {
	row := q.db.QueryRow(ctx, getAccessTokenByRequestID, requestID)
	var i AccessToken
	err := row.Scan(
		&i.Signature,
		&i.RequestData,
		&i.RequestID,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getActiveSessionCount = `-- name: GetActiveSessionCount :one

SELECT COUNT(*) FROM access_tokens WHERE created_at > NOW() - INTERVAL '1 hour'
`

// ===================
// Admin: Statistics
// ===================
func (q *Queries) GetActiveSessionCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getActiveSessionCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getAdminUsers = `-- name: GetAdminUsers :many
SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users WHERE role = 'admin' AND account_status = 'active'
`

func (q *Queries) GetAdminUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.Query(ctx, getAdminUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.EmailVerified,
			&i.PasswordHash,
			&i.DisplayName,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.AccountStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAuthorizeCode = `-- name: GetAuthorizeCode :one
SELECT code, active, request_data, expires_at, created_at FROM authorize_codes WHERE code = $1 LIMIT 1
`

func (q *Queries) GetAuthorizeCode(ctx context.Context, code string) (AuthorizeCode, error) {
	row := q.db.QueryRow(ctx, getAuthorizeCode, code)
	var i AuthorizeCode
	err := row.Scan(
		&i.Code,
		&i.Active,
		&i.RequestData,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getClient = `-- name: GetClient :one
SELECT id, secret, redirect_uris, grant_types, response_types, scopes, public, created_at, updated_at FROM clients WHERE id = $1 LIMIT 1
`

// OAuth Clients
func (q *Queries) GetClient(ctx context.Context, id string) (Client, error) {
	row := q.db.QueryRow(ctx, getClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.Secret,
		&i.RedirectUris,
		&i.GrantTypes,
		&i.ResponseTypes,
		&i.Scopes,
		&i.Public,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getIDPSession = `-- name: GetIDPSession :one
SELECT id, user_id, user_agent, ip_address, created_at, expires_at, revoked_at FROM idp_sessions
WHERE id = $1 AND revoked_at IS NULL AND expires_at > NOW()
LIMIT 1
`

func (q *Queries) GetIDPSession(ctx context.Context, id pgtype.UUID) (IdpSession, error) {
	row := q.db.QueryRow(ctx, getIDPSession, id)
	var i IdpSession
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.UserAgent,
		&i.IpAddress,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.RevokedAt,
	)
	return i, err
}

const getOIDCSession = `-- name: GetOIDCSession :one
SELECT authorize_code, request_data, created_at FROM oidc_sessions WHERE authorize_code = $1 LIMIT 1
`

func (q *Queries) GetOIDCSession(ctx context.Context, authorizeCode string) (OidcSession, error) {
	row := q.db.QueryRow(ctx, getOIDCSession, authorizeCode)
	var i OidcSession
	err := row.Scan(&i.AuthorizeCode, &i.RequestData, &i.CreatedAt)
	return i, err
}

const getOwnerUser = `-- name: GetOwnerUser :one
SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users WHERE role = 'owner' AND account_status = 'active' LIMIT 1
`

func (q *Queries) GetOwnerUser(ctx context.Context) (User, error) {
	row := q.db.QueryRow(ctx, getOwnerUser)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.AccountStatus,
	)
	return i, err
}

const getPARSession = `-- name: GetPARSession :one
SELECT request_uri, request_data, expires_at, created_at FROM par_sessions WHERE request_uri = $1 LIMIT 1
`

func (q *Queries) GetPARSession(ctx context.Context, requestUri string) (ParSession, error) {
	row := q.db.QueryRow(ctx, getPARSession, requestUri)
	var i ParSession
	err := row.Scan(
		&i.RequestUri,
		&i.RequestData,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getPKCESession = `-- name: GetPKCESession :one
SELECT code, request_data, created_at FROM pkce_sessions WHERE code = $1 LIMIT 1
`

func (q *Queries) GetPKCESession(ctx context.Context, code string) (PkceSession, error) {
	row := q.db.QueryRow(ctx, getPKCESession, code)
	var i PkceSession
	err := row.Scan(&i.Code, &i.RequestData, &i.CreatedAt)
	return i, err
}

const getPendingSSFDeliveries = `-- name: GetPendingSSFDeliveries :many
SELECT d.id, d.event_id, d.stream_id, d.jti, d.set_token, d.status, d.attempts, d.max_attempts, d.last_error, d.next_retry_at, d.created_at, d.sent_at, d.acked_at, e.payload, s.endpoint_url, s.authorization_header, s.delivery_method
FROM ssf_event_deliveries d
JOIN ssf_events e ON d.event_id = e.id
JOIN ssf_streams s ON d.stream_id = s.id
WHERE d.status IN ('queued', 'retry')
  AND d.next_retry_at <= NOW()
  AND d.attempts < d.max_attempts
  AND s.status = 'enabled'
  AND s.delivery_method = 'urn:ietf:rfc:8935'
ORDER BY d.created_at ASC
LIMIT $1
FOR UPDATE OF d SKIP LOCKED
`

type GetPendingSSFDeliveriesRow struct {
	ID                  pgtype.UUID        `json:"id"`
	EventID             pgtype.UUID        `json:"event_id"`
	StreamID            pgtype.UUID        `json:"stream_id"`
	Jti                 string             `json:"jti"`
	SetToken            string             `json:"set_token"`
	Status              string             `json:"status"`
	Attempts            int32              `json:"attempts"`
	MaxAttempts         int32              `json:"max_attempts"`
	LastError           *string            `json:"last_error"`
	NextRetryAt         pgtype.Timestamptz `json:"next_retry_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	SentAt              pgtype.Timestamptz `json:"sent_at"`
	AckedAt             pgtype.Timestamptz `json:"acked_at"`
	Payload             []byte             `json:"payload"`
	EndpointUrl         string             `json:"endpoint_url"`
	AuthorizationHeader *string            `json:"authorization_header"`
	DeliveryMethod      string             `json:"delivery_method"`
}

// Fetch deliveries ready for transmission (Push: queued/retry with next_retry_at <= now)
// FOR UPDATE SKIP LOCKED ensures no duplicate processing in multi-instance environments
func (q *Queries) GetPendingSSFDeliveries(ctx context.Context, limit int32) ([]GetPendingSSFDeliveriesRow, error) {
	rows, err := q.db.Query(ctx, getPendingSSFDeliveries, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPendingSSFDeliveriesRow{}
	for rows.Next() {
		var i GetPendingSSFDeliveriesRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.StreamID,
			&i.Jti,
			&i.SetToken,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.SentAt,
			&i.AckedAt,
			&i.Payload,
			&i.EndpointUrl,
			&i.AuthorizationHeader,
			&i.DeliveryMethod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPollSSFDeliveries = `-- name: GetPollSSFDeliveries :many
SELECT d.jti, d.set_token
FROM ssf_event_deliveries d
JOIN ssf_streams s ON d.stream_id = s.id
WHERE d.stream_id = $1
  AND d.status IN ('queued', 'sent')
  AND s.delivery_method = 'urn:ietf:rfc:8936'
ORDER BY d.created_at ASC
LIMIT $2
`

type GetPollSSFDeliveriesParams struct {
	StreamID pgtype.UUID `json:"stream_id"`
	Limit    int32       `json:"limit"`
}

type GetPollSSFDeliveriesRow struct {
	Jti      string `json:"jti"`
	SetToken string `json:"set_token"`
}

// Fetch deliveries for Poll (queued or sent but not acked)
func (q *Queries) GetPollSSFDeliveries(ctx context.Context, arg GetPollSSFDeliveriesParams) ([]GetPollSSFDeliveriesRow, error) {
	rows, err := q.db.Query(ctx, getPollSSFDeliveries, arg.StreamID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPollSSFDeliveriesRow{}
	for rows.Next() {
		var i GetPollSSFDeliveriesRow
		if err := rows.Scan(&i.Jti, &i.SetToken); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecentLoginCount = `-- name: GetRecentLoginCount :one
SELECT COUNT(*) FROM users WHERE last_login_at > NOW() - INTERVAL '24 hours'
`

func (q *Queries) GetRecentLoginCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getRecentLoginCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRecentSSFDeliveryCount = `-- name: GetRecentSSFDeliveryCount :one
SELECT COUNT(*) FROM ssf_event_deliveries WHERE created_at > NOW() - INTERVAL '24 hours'
`

func (q *Queries) GetRecentSSFDeliveryCount(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, getRecentSSFDeliveryCount)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT signature, active, request_data, request_id, access_token_signature, expires_at, created_at FROM refresh_tokens WHERE signature = $1 LIMIT 1
`

func (q *Queries) GetRefreshToken(ctx context.Context, signature string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, signature)
	var i RefreshToken
	err := row.Scan(
		&i.Signature,
		&i.Active,
		&i.RequestData,
		&i.RequestID,
		&i.AccessTokenSignature,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getRefreshTokenByRequestID = `-- name: GetRefreshTokenByRequestID :one
SELECT signature, active, request_data, request_id, access_token_signature, expires_at, created_at FROM refresh_tokens WHERE request_id = $1 LIMIT 1
`

func (q *Queries) GetRefreshTokenByRequestID(ctx context.Context, requestID string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getRefreshTokenByRequestID, requestID)
	var i RefreshToken
	err := row.Scan(
		&i.Signature,
		&i.Active,
		&i.RequestData,
		&i.RequestID,
		&i.AccessTokenSignature,
		&i.ExpiresAt,
		&i.CreatedAt,
	)
	return i, err
}

const getSSFDeliveryStats = `-- name: GetSSFDeliveryStats :one
SELECT
  COUNT(*) as total_deliveries,
  COUNT(*) FILTER (WHERE status = 'sent') as sent_count,
  COUNT(*) FILTER (WHERE status = 'acked') as acked_count,
  COUNT(*) FILTER (WHERE status = 'failed') as failed_count,
  COUNT(*) FILTER (WHERE status = 'queued' OR status = 'retry') as pending_count
FROM ssf_event_deliveries
`

type GetSSFDeliveryStatsRow struct {
	TotalDeliveries int64 `json:"total_deliveries"`
	SentCount       int64 `json:"sent_count"`
	AckedCount      int64 `json:"acked_count"`
	FailedCount     int64 `json:"failed_count"`
	PendingCount    int64 `json:"pending_count"`
}

func (q *Queries) GetSSFDeliveryStats(ctx context.Context) (GetSSFDeliveryStatsRow, error) {
	row := q.db.QueryRow(ctx, getSSFDeliveryStats)
	var i GetSSFDeliveryStatsRow
	err := row.Scan(
		&i.TotalDeliveries,
		&i.SentCount,
		&i.AckedCount,
		&i.FailedCount,
		&i.PendingCount,
	)
	return i, err
}

const getSSFEvent = `-- name: GetSSFEvent :one
SELECT id, event_type, subject_identifier, payload, created_at FROM ssf_events WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSSFEvent(ctx context.Context, id pgtype.UUID) (SsfEvent, error) {
	row := q.db.QueryRow(ctx, getSSFEvent, id)
	var i SsfEvent
	err := row.Scan(
		&i.ID,
		&i.EventType,
		&i.SubjectIdentifier,
		&i.Payload,
		&i.CreatedAt,
	)
	return i, err
}

const getSSFEventDelivery = `-- name: GetSSFEventDelivery :one
SELECT id, event_id, stream_id, jti, set_token, status, attempts, max_attempts, last_error, next_retry_at, created_at, sent_at, acked_at FROM ssf_event_deliveries WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSSFEventDelivery(ctx context.Context, id pgtype.UUID) (SsfEventDelivery, error) {
	row := q.db.QueryRow(ctx, getSSFEventDelivery, id)
	var i SsfEventDelivery
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.StreamID,
		&i.Jti,
		&i.SetToken,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.SentAt,
		&i.AckedAt,
	)
	return i, err
}

const getSSFEventDeliveryByIDWithDetails = `-- name: GetSSFEventDeliveryByIDWithDetails :one
SELECT d.id, d.event_id, d.stream_id, d.jti, d.set_token, d.status, d.attempts, d.max_attempts, d.last_error, d.next_retry_at, d.created_at, d.sent_at, d.acked_at, e.payload, s.endpoint_url, s.authorization_header, s.delivery_method
FROM ssf_event_deliveries d
JOIN ssf_events e ON d.event_id = e.id
JOIN ssf_streams s ON d.stream_id = s.id
WHERE d.id = $1
`

type GetSSFEventDeliveryByIDWithDetailsRow struct {
	ID                  pgtype.UUID        `json:"id"`
	EventID             pgtype.UUID        `json:"event_id"`
	StreamID            pgtype.UUID        `json:"stream_id"`
	Jti                 string             `json:"jti"`
	SetToken            string             `json:"set_token"`
	Status              string             `json:"status"`
	Attempts            int32              `json:"attempts"`
	MaxAttempts         int32              `json:"max_attempts"`
	LastError           *string            `json:"last_error"`
	NextRetryAt         pgtype.Timestamptz `json:"next_retry_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	SentAt              pgtype.Timestamptz `json:"sent_at"`
	AckedAt             pgtype.Timestamptz `json:"acked_at"`
	Payload             []byte             `json:"payload"`
	EndpointUrl         string             `json:"endpoint_url"`
	AuthorizationHeader *string            `json:"authorization_header"`
	DeliveryMethod      string             `json:"delivery_method"`
}

// Fetch a single delivery with all details needed for processing
func (q *Queries) GetSSFEventDeliveryByIDWithDetails(ctx context.Context, id pgtype.UUID) (GetSSFEventDeliveryByIDWithDetailsRow, error) {
	row := q.db.QueryRow(ctx, getSSFEventDeliveryByIDWithDetails, id)
	var i GetSSFEventDeliveryByIDWithDetailsRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.StreamID,
		&i.Jti,
		&i.SetToken,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.SentAt,
		&i.AckedAt,
		&i.Payload,
		&i.EndpointUrl,
		&i.AuthorizationHeader,
		&i.DeliveryMethod,
	)
	return i, err
}

const getSSFEventDeliveryByJTI = `-- name: GetSSFEventDeliveryByJTI :one
SELECT id, event_id, stream_id, jti, set_token, status, attempts, max_attempts, last_error, next_retry_at, created_at, sent_at, acked_at FROM ssf_event_deliveries WHERE jti = $1 LIMIT 1
`

func (q *Queries) GetSSFEventDeliveryByJTI(ctx context.Context, jti string) (SsfEventDelivery, error) {
	row := q.db.QueryRow(ctx, getSSFEventDeliveryByJTI, jti)
	var i SsfEventDelivery
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.StreamID,
		&i.Jti,
		&i.SetToken,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.SentAt,
		&i.AckedAt,
	)
	return i, err
}

const getSSFStream = `-- name: GetSSFStream :one
SELECT id, client_id, audience, delivery_method, endpoint_url, authorization_header, events_requested, events_delivered, status, status_reason, description, created_at, updated_at FROM ssf_streams WHERE id = $1 LIMIT 1
`

func (q *Queries) GetSSFStream(ctx context.Context, id pgtype.UUID) (SsfStream, error) {
	row := q.db.QueryRow(ctx, getSSFStream, id)
	var i SsfStream
	err := row.Scan(
		&i.ID,
		&i.ClientID,
		&i.Audience,
		&i.DeliveryMethod,
		&i.EndpointUrl,
		&i.AuthorizationHeader,
		&i.EventsRequested,
		&i.EventsDelivered,
		&i.Status,
		&i.StatusReason,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getSSFStreamByClientID = `-- name: GetSSFStreamByClientID :many
SELECT id, client_id, audience, delivery_method, endpoint_url, authorization_header, events_requested, events_delivered, status, status_reason, description, created_at, updated_at FROM ssf_streams WHERE client_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetSSFStreamByClientID(ctx context.Context, clientID *string) ([]SsfStream, error) {
	rows, err := q.db.Query(ctx, getSSFStreamByClientID, clientID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SsfStream{}
	for rows.Next() {
		var i SsfStream
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Audience,
			&i.DeliveryMethod,
			&i.EndpointUrl,
			&i.AuthorizationHeader,
			&i.EventsRequested,
			&i.EventsDelivered,
			&i.Status,
			&i.StatusReason,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSSFStreamSubject = `-- name: GetSSFStreamSubject :one
SELECT id, stream_id, subject_format, subject_identifier, verified, created_at FROM ssf_stream_subjects
WHERE stream_id = $1 AND subject_format = $2 AND subject_identifier = $3
LIMIT 1
`

type GetSSFStreamSubjectParams struct {
	StreamID          pgtype.UUID `json:"stream_id"`
	SubjectFormat     string      `json:"subject_format"`
	SubjectIdentifier string      `json:"subject_identifier"`
}

func (q *Queries) GetSSFStreamSubject(ctx context.Context, arg GetSSFStreamSubjectParams) (SsfStreamSubject, error) {
	row := q.db.QueryRow(ctx, getSSFStreamSubject, arg.StreamID, arg.SubjectFormat, arg.SubjectIdentifier)
	var i SsfStreamSubject
	err := row.Scan(
		&i.ID,
		&i.StreamID,
		&i.SubjectFormat,
		&i.SubjectIdentifier,
		&i.Verified,
		&i.CreatedAt,
	)
	return i, err
}

const getStreamsBySubjectIdentifier = `-- name: GetStreamsBySubjectIdentifier :many
SELECT DISTINCT s.id, s.client_id, s.audience, s.delivery_method, s.endpoint_url, s.authorization_header, s.events_requested, s.events_delivered, s.status, s.status_reason, s.description, s.created_at, s.updated_at FROM ssf_streams s
JOIN ssf_stream_subjects sub ON s.id = sub.stream_id
WHERE sub.subject_identifier = $1 AND s.status = 'enabled'
`

// Subject が登録されているストリーム（enabled のみ）を取得
func (q *Queries) GetStreamsBySubjectIdentifier(ctx context.Context, subjectIdentifier string) ([]SsfStream, error) {
	rows, err := q.db.Query(ctx, getStreamsBySubjectIdentifier, subjectIdentifier)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SsfStream{}
	for rows.Next() {
		var i SsfStream
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Audience,
			&i.DeliveryMethod,
			&i.EndpointUrl,
			&i.AuthorizationHeader,
			&i.EventsRequested,
			&i.EventsDelivered,
			&i.Status,
			&i.StatusReason,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users WHERE email = $1 AND account_status = 'active' LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.AccountStatus,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users WHERE id = $1 AND account_status = 'active' LIMIT 1
`

func (q *Queries) GetUserByID(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.AccountStatus,
	)
	return i, err
}

const getUserByIDIncludeInactive = `-- name: GetUserByIDIncludeInactive :one
SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUserByIDIncludeInactive(ctx context.Context, id pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByIDIncludeInactive, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.AccountStatus,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users WHERE username = $1 AND account_status = 'active' LIMIT 1
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.EmailVerified,
		&i.PasswordHash,
		&i.DisplayName,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastLoginAt,
		&i.AccountStatus,
	)
	return i, err
}

const hasOwner = `-- name: HasOwner :one
SELECT EXISTS(SELECT 1 FROM users WHERE role = 'owner' AND account_status != 'deleted') AS has_owner
`

func (q *Queries) HasOwner(ctx context.Context) (bool, error) {
	row := q.db.QueryRow(ctx, hasOwner)
	var has_owner bool
	err := row.Scan(&has_owner)
	return has_owner, err
}

const invalidateAuthorizeCode = `-- name: InvalidateAuthorizeCode :exec
UPDATE authorize_codes SET active = false WHERE code = $1
`

func (q *Queries) InvalidateAuthorizeCode(ctx context.Context, code string) error {
	_, err := q.db.Exec(ctx, invalidateAuthorizeCode, code)
	return err
}

const invalidateRefreshToken = `-- name: InvalidateRefreshToken :exec
UPDATE refresh_tokens SET active = false WHERE signature = $1
`

func (q *Queries) InvalidateRefreshToken(ctx context.Context, signature string) error {
	_, err := q.db.Exec(ctx, invalidateRefreshToken, signature)
	return err
}

const invalidateRefreshTokenByRequestID = `-- name: InvalidateRefreshTokenByRequestID :exec
UPDATE refresh_tokens SET active = false WHERE request_id = $1
`

func (q *Queries) InvalidateRefreshTokenByRequestID(ctx context.Context, requestID string) error {
	_, err := q.db.Exec(ctx, invalidateRefreshTokenByRequestID, requestID)
	return err
}

const isJTIBlacklisted = `-- name: IsJTIBlacklisted :one
SELECT EXISTS(
    SELECT 1 FROM blacklisted_jtis
    WHERE jti = $1 AND expires_at > NOW()
) AS exists
`

// Blacklisted JTIs
func (q *Queries) IsJTIBlacklisted(ctx context.Context, jti string) (bool, error) {
	row := q.db.QueryRow(ctx, isJTIBlacklisted, jti)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isSubjectInStream = `-- name: IsSubjectInStream :one
SELECT EXISTS(
  SELECT 1 FROM ssf_stream_subjects
  WHERE stream_id = $1 AND subject_identifier = $2
) AS exists
`

type IsSubjectInStreamParams struct {
	StreamID          pgtype.UUID `json:"stream_id"`
	SubjectIdentifier string      `json:"subject_identifier"`
}

// 特定の Subject がストリームに登録されているか確認
func (q *Queries) IsSubjectInStream(ctx context.Context, arg IsSubjectInStreamParams) (bool, error) {
	row := q.db.QueryRow(ctx, isSubjectInStream, arg.StreamID, arg.SubjectIdentifier)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const isUserAdmin = `-- name: IsUserAdmin :one
SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND role = 'admin' AND account_status = 'active') AS is_admin
`

func (q *Queries) IsUserAdmin(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isUserAdmin, id)
	var is_admin bool
	err := row.Scan(&is_admin)
	return is_admin, err
}

const isUserAdminOrOwner = `-- name: IsUserAdminOrOwner :one
SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND role IN ('admin', 'owner') AND account_status = 'active') AS is_admin_or_owner
`

func (q *Queries) IsUserAdminOrOwner(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isUserAdminOrOwner, id)
	var is_admin_or_owner bool
	err := row.Scan(&is_admin_or_owner)
	return is_admin_or_owner, err
}

const isUserOwner = `-- name: IsUserOwner :one
SELECT EXISTS(SELECT 1 FROM users WHERE id = $1 AND role = 'owner' AND account_status = 'active') AS is_owner
`

func (q *Queries) IsUserOwner(ctx context.Context, id pgtype.UUID) (bool, error) {
	row := q.db.QueryRow(ctx, isUserOwner, id)
	var is_owner bool
	err := row.Scan(&is_owner)
	return is_owner, err
}

const listClients = `-- name: ListClients :many

SELECT id, secret, redirect_uris, grant_types, response_types, scopes, public, created_at, updated_at FROM clients ORDER BY created_at DESC
`

// ===================
// Admin: Client Management
// ===================
func (q *Queries) ListClients(ctx context.Context) ([]Client, error) {
	rows, err := q.db.Query(ctx, listClients)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Client{}
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.Secret,
			&i.RedirectUris,
			&i.GrantTypes,
			&i.ResponseTypes,
			&i.Scopes,
			&i.Public,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSFEventDeliveries = `-- name: ListSSFEventDeliveries :many
SELECT d.id, d.event_id, d.stream_id, d.jti, d.set_token, d.status, d.attempts, d.max_attempts, d.last_error, d.next_retry_at, d.created_at, d.sent_at, d.acked_at, e.event_type, e.subject_identifier
FROM ssf_event_deliveries d
JOIN ssf_events e ON d.event_id = e.id
ORDER BY d.created_at DESC
LIMIT $1 OFFSET $2
`

type ListSSFEventDeliveriesParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListSSFEventDeliveriesRow struct {
	ID                pgtype.UUID        `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	StreamID          pgtype.UUID        `json:"stream_id"`
	Jti               string             `json:"jti"`
	SetToken          string             `json:"set_token"`
	Status            string             `json:"status"`
	Attempts          int32              `json:"attempts"`
	MaxAttempts       int32              `json:"max_attempts"`
	LastError         *string            `json:"last_error"`
	NextRetryAt       pgtype.Timestamptz `json:"next_retry_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	SentAt            pgtype.Timestamptz `json:"sent_at"`
	AckedAt           pgtype.Timestamptz `json:"acked_at"`
	EventType         string             `json:"event_type"`
	SubjectIdentifier *string            `json:"subject_identifier"`
}

func (q *Queries) ListSSFEventDeliveries(ctx context.Context, arg ListSSFEventDeliveriesParams) ([]ListSSFEventDeliveriesRow, error) {
	rows, err := q.db.Query(ctx, listSSFEventDeliveries, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSSFEventDeliveriesRow{}
	for rows.Next() {
		var i ListSSFEventDeliveriesRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.StreamID,
			&i.Jti,
			&i.SetToken,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.SentAt,
			&i.AckedAt,
			&i.EventType,
			&i.SubjectIdentifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSFEventDeliveriesByEvent = `-- name: ListSSFEventDeliveriesByEvent :many
SELECT d.id, d.event_id, d.stream_id, d.jti, d.set_token, d.status, d.attempts, d.max_attempts, d.last_error, d.next_retry_at, d.created_at, d.sent_at, d.acked_at, s.endpoint_url, s.delivery_method
FROM ssf_event_deliveries d
JOIN ssf_streams s ON d.stream_id = s.id
WHERE d.event_id = $1
ORDER BY d.created_at DESC
`

type ListSSFEventDeliveriesByEventRow struct {
	ID             pgtype.UUID        `json:"id"`
	EventID        pgtype.UUID        `json:"event_id"`
	StreamID       pgtype.UUID        `json:"stream_id"`
	Jti            string             `json:"jti"`
	SetToken       string             `json:"set_token"`
	Status         string             `json:"status"`
	Attempts       int32              `json:"attempts"`
	MaxAttempts    int32              `json:"max_attempts"`
	LastError      *string            `json:"last_error"`
	NextRetryAt    pgtype.Timestamptz `json:"next_retry_at"`
	CreatedAt      pgtype.Timestamptz `json:"created_at"`
	SentAt         pgtype.Timestamptz `json:"sent_at"`
	AckedAt        pgtype.Timestamptz `json:"acked_at"`
	EndpointUrl    string             `json:"endpoint_url"`
	DeliveryMethod string             `json:"delivery_method"`
}

func (q *Queries) ListSSFEventDeliveriesByEvent(ctx context.Context, eventID pgtype.UUID) ([]ListSSFEventDeliveriesByEventRow, error) {
	rows, err := q.db.Query(ctx, listSSFEventDeliveriesByEvent, eventID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSSFEventDeliveriesByEventRow{}
	for rows.Next() {
		var i ListSSFEventDeliveriesByEventRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.StreamID,
			&i.Jti,
			&i.SetToken,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.SentAt,
			&i.AckedAt,
			&i.EndpointUrl,
			&i.DeliveryMethod,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSFEventDeliveriesByStream = `-- name: ListSSFEventDeliveriesByStream :many
SELECT d.id, d.event_id, d.stream_id, d.jti, d.set_token, d.status, d.attempts, d.max_attempts, d.last_error, d.next_retry_at, d.created_at, d.sent_at, d.acked_at, e.event_type, e.subject_identifier
FROM ssf_event_deliveries d
JOIN ssf_events e ON d.event_id = e.id
WHERE d.stream_id = $1
ORDER BY d.created_at DESC
LIMIT $2 OFFSET $3
`

type ListSSFEventDeliveriesByStreamParams struct {
	StreamID pgtype.UUID `json:"stream_id"`
	Limit    int32       `json:"limit"`
	Offset   int32       `json:"offset"`
}

type ListSSFEventDeliveriesByStreamRow struct {
	ID                pgtype.UUID        `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	StreamID          pgtype.UUID        `json:"stream_id"`
	Jti               string             `json:"jti"`
	SetToken          string             `json:"set_token"`
	Status            string             `json:"status"`
	Attempts          int32              `json:"attempts"`
	MaxAttempts       int32              `json:"max_attempts"`
	LastError         *string            `json:"last_error"`
	NextRetryAt       pgtype.Timestamptz `json:"next_retry_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	SentAt            pgtype.Timestamptz `json:"sent_at"`
	AckedAt           pgtype.Timestamptz `json:"acked_at"`
	EventType         string             `json:"event_type"`
	SubjectIdentifier *string            `json:"subject_identifier"`
}

func (q *Queries) ListSSFEventDeliveriesByStream(ctx context.Context, arg ListSSFEventDeliveriesByStreamParams) ([]ListSSFEventDeliveriesByStreamRow, error) {
	rows, err := q.db.Query(ctx, listSSFEventDeliveriesByStream, arg.StreamID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSSFEventDeliveriesByStreamRow{}
	for rows.Next() {
		var i ListSSFEventDeliveriesByStreamRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.StreamID,
			&i.Jti,
			&i.SetToken,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.SentAt,
			&i.AckedAt,
			&i.EventType,
			&i.SubjectIdentifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSFEventDeliveriesFiltered = `-- name: ListSSFEventDeliveriesFiltered :many
SELECT d.id, d.event_id, d.stream_id, d.jti, d.set_token, d.status, d.attempts, d.max_attempts, d.last_error, d.next_retry_at, d.created_at, d.sent_at, d.acked_at, e.event_type, e.subject_identifier
FROM ssf_event_deliveries d
JOIN ssf_events e ON d.event_id = e.id
WHERE ($3::uuid IS NULL OR d.stream_id = $3)
  AND ($4::text IS NULL OR d.status = $4)
  AND ($5::text IS NULL OR e.event_type = $5)
ORDER BY d.created_at DESC
LIMIT $1 OFFSET $2
`

type ListSSFEventDeliveriesFilteredParams struct {
	Limit     int32       `json:"limit"`
	Offset    int32       `json:"offset"`
	StreamID  pgtype.UUID `json:"stream_id"`
	Status    *string     `json:"status"`
	EventType *string     `json:"event_type"`
}

type ListSSFEventDeliveriesFilteredRow struct {
	ID                pgtype.UUID        `json:"id"`
	EventID           pgtype.UUID        `json:"event_id"`
	StreamID          pgtype.UUID        `json:"stream_id"`
	Jti               string             `json:"jti"`
	SetToken          string             `json:"set_token"`
	Status            string             `json:"status"`
	Attempts          int32              `json:"attempts"`
	MaxAttempts       int32              `json:"max_attempts"`
	LastError         *string            `json:"last_error"`
	NextRetryAt       pgtype.Timestamptz `json:"next_retry_at"`
	CreatedAt         pgtype.Timestamptz `json:"created_at"`
	SentAt            pgtype.Timestamptz `json:"sent_at"`
	AckedAt           pgtype.Timestamptz `json:"acked_at"`
	EventType         string             `json:"event_type"`
	SubjectIdentifier *string            `json:"subject_identifier"`
}

func (q *Queries) ListSSFEventDeliveriesFiltered(ctx context.Context, arg ListSSFEventDeliveriesFilteredParams) ([]ListSSFEventDeliveriesFilteredRow, error) {
	rows, err := q.db.Query(ctx, listSSFEventDeliveriesFiltered,
		arg.Limit,
		arg.Offset,
		arg.StreamID,
		arg.Status,
		arg.EventType,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListSSFEventDeliveriesFilteredRow{}
	for rows.Next() {
		var i ListSSFEventDeliveriesFilteredRow
		if err := rows.Scan(
			&i.ID,
			&i.EventID,
			&i.StreamID,
			&i.Jti,
			&i.SetToken,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.NextRetryAt,
			&i.CreatedAt,
			&i.SentAt,
			&i.AckedAt,
			&i.EventType,
			&i.SubjectIdentifier,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSFEvents = `-- name: ListSSFEvents :many
SELECT id, event_type, subject_identifier, payload, created_at FROM ssf_events
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListSSFEventsParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListSSFEvents(ctx context.Context, arg ListSSFEventsParams) ([]SsfEvent, error) {
	rows, err := q.db.Query(ctx, listSSFEvents, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SsfEvent{}
	for rows.Next() {
		var i SsfEvent
		if err := rows.Scan(
			&i.ID,
			&i.EventType,
			&i.SubjectIdentifier,
			&i.Payload,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSFStreamSubjects = `-- name: ListSSFStreamSubjects :many
SELECT id, stream_id, subject_format, subject_identifier, verified, created_at FROM ssf_stream_subjects
WHERE stream_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListSSFStreamSubjects(ctx context.Context, streamID pgtype.UUID) ([]SsfStreamSubject, error) {
	rows, err := q.db.Query(ctx, listSSFStreamSubjects, streamID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SsfStreamSubject{}
	for rows.Next() {
		var i SsfStreamSubject
		if err := rows.Scan(
			&i.ID,
			&i.StreamID,
			&i.SubjectFormat,
			&i.SubjectIdentifier,
			&i.Verified,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSFStreams = `-- name: ListSSFStreams :many
SELECT id, client_id, audience, delivery_method, endpoint_url, authorization_header, events_requested, events_delivered, status, status_reason, description, created_at, updated_at FROM ssf_streams ORDER BY created_at DESC
`

func (q *Queries) ListSSFStreams(ctx context.Context) ([]SsfStream, error) {
	rows, err := q.db.Query(ctx, listSSFStreams)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SsfStream{}
	for rows.Next() {
		var i SsfStream
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Audience,
			&i.DeliveryMethod,
			&i.EndpointUrl,
			&i.AuthorizationHeader,
			&i.EventsRequested,
			&i.EventsDelivered,
			&i.Status,
			&i.StatusReason,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSSFStreamsByStatus = `-- name: ListSSFStreamsByStatus :many
SELECT id, client_id, audience, delivery_method, endpoint_url, authorization_header, events_requested, events_delivered, status, status_reason, description, created_at, updated_at FROM ssf_streams WHERE status = $1 ORDER BY created_at DESC
`

func (q *Queries) ListSSFStreamsByStatus(ctx context.Context, status string) ([]SsfStream, error) {
	rows, err := q.db.Query(ctx, listSSFStreamsByStatus, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SsfStream{}
	for rows.Next() {
		var i SsfStream
		if err := rows.Scan(
			&i.ID,
			&i.ClientID,
			&i.Audience,
			&i.DeliveryMethod,
			&i.EndpointUrl,
			&i.AuthorizationHeader,
			&i.EventsRequested,
			&i.EventsDelivered,
			&i.Status,
			&i.StatusReason,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserSessions = `-- name: ListUserSessions :many
SELECT id, user_id, user_agent, ip_address, created_at, expires_at, revoked_at FROM idp_sessions
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUserSessionsParams struct {
	UserID pgtype.UUID `json:"user_id"`
	Limit  int32       `json:"limit"`
	Offset int32       `json:"offset"`
}

func (q *Queries) ListUserSessions(ctx context.Context, arg ListUserSessionsParams) ([]IdpSession, error) {
	rows, err := q.db.Query(ctx, listUserSessions, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []IdpSession{}
	for rows.Next() {
		var i IdpSession
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.UserAgent,
			&i.IpAddress,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.RevokedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many

SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users
WHERE account_status != 'deleted'
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListUsersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

// ===================
// Admin: User Management
// ===================
func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.EmailVerified,
			&i.PasswordHash,
			&i.DisplayName,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.AccountStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByStatus = `-- name: ListUsersByStatus :many
SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users
WHERE account_status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUsersByStatusParams struct {
	AccountStatus string `json:"account_status"`
	Limit         int32  `json:"limit"`
	Offset        int32  `json:"offset"`
}

func (q *Queries) ListUsersByStatus(ctx context.Context, arg ListUsersByStatusParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsersByStatus, arg.AccountStatus, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.EmailVerified,
			&i.PasswordHash,
			&i.DisplayName,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.AccountStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockSSFEventDeliveryForProcessing = `-- name: LockSSFEventDeliveryForProcessing :one
SELECT d.id, d.event_id, d.stream_id, d.jti, d.set_token, d.status, d.attempts, d.max_attempts, d.last_error, d.next_retry_at, d.created_at, d.sent_at, d.acked_at, e.payload, s.endpoint_url, s.authorization_header, s.delivery_method
FROM ssf_event_deliveries d
JOIN ssf_events e ON d.event_id = e.id
JOIN ssf_streams s ON d.stream_id = s.id
WHERE d.id = $1
  AND d.status = 'queued'
  AND s.delivery_method = 'urn:ietf:rfc:8935'
FOR UPDATE OF d SKIP LOCKED
`

type LockSSFEventDeliveryForProcessingRow struct {
	ID                  pgtype.UUID        `json:"id"`
	EventID             pgtype.UUID        `json:"event_id"`
	StreamID            pgtype.UUID        `json:"stream_id"`
	Jti                 string             `json:"jti"`
	SetToken            string             `json:"set_token"`
	Status              string             `json:"status"`
	Attempts            int32              `json:"attempts"`
	MaxAttempts         int32              `json:"max_attempts"`
	LastError           *string            `json:"last_error"`
	NextRetryAt         pgtype.Timestamptz `json:"next_retry_at"`
	CreatedAt           pgtype.Timestamptz `json:"created_at"`
	SentAt              pgtype.Timestamptz `json:"sent_at"`
	AckedAt             pgtype.Timestamptz `json:"acked_at"`
	Payload             []byte             `json:"payload"`
	EndpointUrl         string             `json:"endpoint_url"`
	AuthorizationHeader *string            `json:"authorization_header"`
	DeliveryMethod      string             `json:"delivery_method"`
}

// Lock a single delivery for immediate processing (used by goroutine)
// Uses FOR UPDATE SKIP LOCKED to avoid conflicts with DB poller
// Returns no rows if already locked or not in queued status
func (q *Queries) LockSSFEventDeliveryForProcessing(ctx context.Context, id pgtype.UUID) (LockSSFEventDeliveryForProcessingRow, error) {
	row := q.db.QueryRow(ctx, lockSSFEventDeliveryForProcessing, id)
	var i LockSSFEventDeliveryForProcessingRow
	err := row.Scan(
		&i.ID,
		&i.EventID,
		&i.StreamID,
		&i.Jti,
		&i.SetToken,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.NextRetryAt,
		&i.CreatedAt,
		&i.SentAt,
		&i.AckedAt,
		&i.Payload,
		&i.EndpointUrl,
		&i.AuthorizationHeader,
		&i.DeliveryMethod,
	)
	return i, err
}

const markSSFDeliveryFailed = `-- name: MarkSSFDeliveryFailed :exec
UPDATE ssf_event_deliveries SET
    status = CASE WHEN attempts + 1 >= max_attempts THEN 'failed' ELSE 'retry' END,
    attempts = attempts + 1,
    last_error = $2,
    next_retry_at = NOW() + ($3 * INTERVAL '1 second')
WHERE id = $1
`

type MarkSSFDeliveryFailedParams struct {
	ID        pgtype.UUID `json:"id"`
	LastError *string     `json:"last_error"`
	Column3   interface{} `json:"column_3"`
}

func (q *Queries) MarkSSFDeliveryFailed(ctx context.Context, arg MarkSSFDeliveryFailedParams) error {
	_, err := q.db.Exec(ctx, markSSFDeliveryFailed, arg.ID, arg.LastError, arg.Column3)
	return err
}

const markSSFDeliverySent = `-- name: MarkSSFDeliverySent :exec
UPDATE ssf_event_deliveries SET
    status = 'sent',
    sent_at = NOW(),
    last_error = NULL
WHERE id = $1
`

func (q *Queries) MarkSSFDeliverySent(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, markSSFDeliverySent, id)
	return err
}

const revokeSession = `-- name: RevokeSession :exec
UPDATE idp_sessions
SET revoked_at = NOW()
WHERE id = $1
`

func (q *Queries) RevokeSession(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeSession, id)
	return err
}

const revokeUserSessions = `-- name: RevokeUserSessions :exec
UPDATE idp_sessions
SET revoked_at = NOW()
WHERE user_id = $1 AND revoked_at IS NULL
`

// Revoke all active sessions for a user (used by SLO)
func (q *Queries) RevokeUserSessions(ctx context.Context, userID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, revokeUserSessions, userID)
	return err
}

const searchUsers = `-- name: SearchUsers :many
SELECT id, username, email, email_verified, password_hash, display_name, role, created_at, updated_at, last_login_at, account_status FROM users
WHERE (username ILIKE $1 OR email ILIKE $1 OR display_name ILIKE $1)
  AND account_status != 'deleted'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchUsersParams struct {
	Username string `json:"username"`
	Limit    int32  `json:"limit"`
	Offset   int32  `json:"offset"`
}

func (q *Queries) SearchUsers(ctx context.Context, arg SearchUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, searchUsers, arg.Username, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.EmailVerified,
			&i.PasswordHash,
			&i.DisplayName,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastLoginAt,
			&i.AccountStatus,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateClient = `-- name: UpdateClient :exec
UPDATE clients SET
    secret = $2,
    redirect_uris = $3,
    grant_types = $4,
    response_types = $5,
    scopes = $6,
    public = $7,
    updated_at = NOW()
WHERE id = $1
`

type UpdateClientParams struct {
	ID            string `json:"id"`
	Secret        []byte `json:"secret"`
	RedirectUris  []byte `json:"redirect_uris"`
	GrantTypes    []byte `json:"grant_types"`
	ResponseTypes []byte `json:"response_types"`
	Scopes        []byte `json:"scopes"`
	Public        bool   `json:"public"`
}

func (q *Queries) UpdateClient(ctx context.Context, arg UpdateClientParams) error {
	_, err := q.db.Exec(ctx, updateClient,
		arg.ID,
		arg.Secret,
		arg.RedirectUris,
		arg.GrantTypes,
		arg.ResponseTypes,
		arg.Scopes,
		arg.Public,
	)
	return err
}

const updateClientSecret = `-- name: UpdateClientSecret :exec
UPDATE clients SET secret = $2, updated_at = NOW() WHERE id = $1
`

type UpdateClientSecretParams struct {
	ID     string `json:"id"`
	Secret []byte `json:"secret"`
}

func (q *Queries) UpdateClientSecret(ctx context.Context, arg UpdateClientSecretParams) error {
	_, err := q.db.Exec(ctx, updateClientSecret, arg.ID, arg.Secret)
	return err
}

const updateSSFStream = `-- name: UpdateSSFStream :exec
UPDATE ssf_streams SET
    audience = $2,
    delivery_method = $3,
    endpoint_url = $4,
    authorization_header = $5,
    events_requested = $6,
    events_delivered = $7,
    description = $8,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSSFStreamParams struct {
	ID                  pgtype.UUID `json:"id"`
	Audience            []string    `json:"audience"`
	DeliveryMethod      string      `json:"delivery_method"`
	EndpointUrl         string      `json:"endpoint_url"`
	AuthorizationHeader *string     `json:"authorization_header"`
	EventsRequested     []string    `json:"events_requested"`
	EventsDelivered     []string    `json:"events_delivered"`
	Description         *string     `json:"description"`
}

func (q *Queries) UpdateSSFStream(ctx context.Context, arg UpdateSSFStreamParams) error {
	_, err := q.db.Exec(ctx, updateSSFStream,
		arg.ID,
		arg.Audience,
		arg.DeliveryMethod,
		arg.EndpointUrl,
		arg.AuthorizationHeader,
		arg.EventsRequested,
		arg.EventsDelivered,
		arg.Description,
	)
	return err
}

const updateSSFStreamStatus = `-- name: UpdateSSFStreamStatus :exec
UPDATE ssf_streams SET
    status = $2,
    status_reason = $3,
    updated_at = NOW()
WHERE id = $1
`

type UpdateSSFStreamStatusParams struct {
	ID           pgtype.UUID `json:"id"`
	Status       string      `json:"status"`
	StatusReason *string     `json:"status_reason"`
}

func (q *Queries) UpdateSSFStreamStatus(ctx context.Context, arg UpdateSSFStreamStatusParams) error {
	_, err := q.db.Exec(ctx, updateSSFStreamStatus, arg.ID, arg.Status, arg.StatusReason)
	return err
}

const updateUserAccountStatus = `-- name: UpdateUserAccountStatus :exec
UPDATE users SET account_status = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUserAccountStatusParams struct {
	ID            pgtype.UUID `json:"id"`
	AccountStatus string      `json:"account_status"`
}

func (q *Queries) UpdateUserAccountStatus(ctx context.Context, arg UpdateUserAccountStatusParams) error {
	_, err := q.db.Exec(ctx, updateUserAccountStatus, arg.ID, arg.AccountStatus)
	return err
}

const updateUserDisplayName = `-- name: UpdateUserDisplayName :exec
UPDATE users SET display_name = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUserDisplayNameParams struct {
	ID          pgtype.UUID `json:"id"`
	DisplayName *string     `json:"display_name"`
}

func (q *Queries) UpdateUserDisplayName(ctx context.Context, arg UpdateUserDisplayNameParams) error {
	_, err := q.db.Exec(ctx, updateUserDisplayName, arg.ID, arg.DisplayName)
	return err
}

const updateUserEmailVerified = `-- name: UpdateUserEmailVerified :exec
UPDATE users SET email_verified = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUserEmailVerifiedParams struct {
	ID            pgtype.UUID `json:"id"`
	EmailVerified bool        `json:"email_verified"`
}

func (q *Queries) UpdateUserEmailVerified(ctx context.Context, arg UpdateUserEmailVerifiedParams) error {
	_, err := q.db.Exec(ctx, updateUserEmailVerified, arg.ID, arg.EmailVerified)
	return err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users SET last_login_at = NOW() WHERE id = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, id)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET password_hash = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUserPasswordParams struct {
	ID           pgtype.UUID `json:"id"`
	PasswordHash []byte      `json:"password_hash"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.ID, arg.PasswordHash)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE users SET role = $2, updated_at = NOW() WHERE id = $1
`

type UpdateUserRoleParams struct {
	ID   pgtype.UUID `json:"id"`
	Role string      `json:"role"`
}

func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.Exec(ctx, updateUserRole, arg.ID, arg.Role)
	return err
}
